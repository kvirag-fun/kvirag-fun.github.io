<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Snake Game</title>
    <link rel="icon" type="image/x-icon" href="tab_icon.ico?v=1">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            color: white;
            
            /* Disable touch controls */
            overflow: hidden;
            height: 100vh;
            touch-action: none;
            overscroll-behavior: none;

        }
        canvas {
            border: 3px solid #16213e;
            border-radius: 10px;
            background: #0f3460;
            box-shadow: 0 0 20px rgba(0,255,255,0.3);
        }
        .score {
            font-size: 24px;
            margin: 20px 0;
            text-shadow: 0 0 10px #00ffff;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <audio id="gameOverSound" preload="auto">
        <source src="ugh_05s.mp3" type="audio/mpeg">
    </audio>
    <audio id="foodEatingSound" preload="auto">
        <source src="food.mp3" type="audio/mpeg">
    </audio>
    
    <div class="score">
        Score: <span id="score">0</span> | 
        Level: <span id="level">1</span> | 
        High Score: <span id="highScore">0</span>
    </div>

    <!-- Flexbox side-by-side -->
    <div class="flex-container" style="width: 100%; max-width: 400px; margin: 10px 0; display: flex; gap: 30px; align-items: flex-start">
        <!-- Leaderboard -->
        <div class="leaderboard" style="font-size: 14px; margin: 10px 0 10px 0; text-shadow: 0 0 5px #00ffff; line-height: 1.3em; text-align: left; width: 200px;">
            Leaderboard:<br>
            <div id="topScoresList" style="margin-top: 2px; font-size: 12px;">
                1. 0<br>2. 0<br>3. 0<br>4. 0<br>5. 0
            </div>
        </div>
    
        <!-- Settings -->
        <div class="settings" style="font-size: 14px; margin: 10px 0 10px 0; text-shadow: 0 0 5px #00ffff; line-height: 1.3em; text-align: left; width: 200px;">
            Settings:<br>
            <label style="font-size: 12px;">
                <input type="checkbox" id="soundToggle" style="cursor: pointer;"> Sound on
            </label>
        </div>
    </div>
    
    <!-- Game canvas -->
    <canvas id="gameCanvas" width="400" height="400"></canvas>
        
    <div class="controls">
        <div>Use ARROW KEYS or SWIPE to move</div>
        <div id="gameOver" style="height: 30px; visibility: hidden; color:#ff0000; font-size:20px;">
            Game Over! Double-tap or press R to restart.
        </div>
    </div>

    <div class="version">v<span id="version">0.2.03</span></div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const gameOverElement = document.getElementById('gameOver');
        const soundToggle = document.getElementById('soundToggle');

        // Game settings
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

        let snake = [
            {x: 10, y: 10}
        ];
        
        let food = {};
        let badFood = {}
        
        let dx = 0;
        let dy = 0;
        let score = 0;
        let gameRunning = true;
        let gameSpeed = 150;
        let gameInterval;

        // Input queue settings
        let inputQueue = []
        
        //Double tap settings
        let lastTap = 0;
        const doubleTapDelay = 400;

        let lastUpdateTime = 0
        
        // High score management
        function getHighScore() {
            return parseInt(localStorage.getItem('snakeHighScore')) || 0;
        }

        function setHighScore(score) {
            const currentHigh = getHighScore();
            if (score > currentHigh) {
                localStorage.setItem('snakeHighScore', score);
                document.getElementById('highScore').textContent = score;
            }
        }

        function updateHighScoreDisplay() {
            document.getElementById('highScore').textContent = getHighScore();
        }

        // Leaderboard management
        function getLeaderboard() {
            const scores = localStorage.getItem('snakeTopScores');
            return scores ? JSON.parse(scores) : [];
        }
        
        function updateLeaderboard(newScore) {
            let scores = getLeaderboard();
            
            // Add new score
            scores.push(newScore);
            
            // Sort descending and keep top 5
            scores.sort((a, b) => b - a);
            scores = scores.slice(0, 5);
            
            // Save back to localStorage
            localStorage.setItem('snakeTopScores', JSON.stringify(scores));
            
            // Update display
            displayLeaderboard();
        }
        
        function displayLeaderboard() {
            const scores = getLeaderboard();
            
            // Always create exactly 5 scores (fill with 0s)
            let displayScores = [...scores];
            while (displayScores.length < 5) {
                displayScores.push(0);
            }
            
            const topScoresElement = document.getElementById('topScoresList');
            topScoresElement.innerHTML = displayScores.map((score, index) => 
                `${index + 1}. ${score}`
            ).join('<br>');
        }        

        function updateLevelDisplay(score) {
            let level;
            if (score < 100) level = 1;
            else if (score < 300) level = 2;
            else if (score < 600) level = 3;
            else if (score < 900) level = 4;
            else level = 5;
            
            levelElement.textContent = level;
        }

        // Generate random food position, but check collision with snake
        function randomFood() {
            let validPosition = false;
            
            while (!validPosition) {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                
                // Check if food is on any snake segment
                validPosition = !snake.some(segment => segment.x === food.x && segment.y === food.y);
            }
        }

        function randomBadFood() {
            let validPosition = false;

            while (!validPosition) {
                badFood = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                
                // Check if  bad food is on any snake segment
                validPosition = !snake.some(segment => segment.x === food.x && segment.y === food.y);
            }
        }
        
        // Draw game elements
        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw food with stem
            ctx.fillStyle = '#ff0000';  // Red apple outline
            ctx.fillRect(food.x * gridSize + 2, food.y * gridSize + 4, gridSize - 4, gridSize - 6);
            
            ctx.fillStyle = '#B5514D';  // Red apple middle
            ctx.fillRect(food.x * gridSize + 2, food.y * gridSize + 4, gridSize - 6, gridSize - 8);
            
            ctx.fillStyle = '#2b1d0e';  // Dark brown stem
            ctx.fillRect(food.x * gridSize + 8, food.y * gridSize, 4, 4);
            
            ctx.fillStyle = '#32CD32';  // Lime green leaf
            ctx.fillRect(food.x * gridSize + 13, food.y * gridSize + 1, 3, 2);

            // Draw bad food with stem
            ctx.fillStyle = '#B5514D';  // Moldy apple outline 
            ctx.fillRect(badFood.x * gridSize + 2, badFood.y * gridSize + 4, gridSize - 4, gridSize - 6);
            
            ctx.fillStyle = '#4A4428';  // Red apple middle 
            ctx.fillRect(badFood.x * gridSize + 2, badFood.y * gridSize + 4, gridSize - 6, gridSize - 8);

            ctx.fillStyle = '#292E26';  // Black moldy spots
            ctx.fillRect(badFood.x * gridSize + 6, badFood.y * gridSize + 6, 3, 3);
            ctx.fillRect(badFood.x * gridSize + 12, badFood.y * gridSize + 10, 2, 2);
            
            ctx.fillStyle = '#2b1d0e';  // Dark brown stem
            ctx.fillRect(badFood.x * gridSize + 8, badFood.y * gridSize, 4, 4);
            
            ctx.fillStyle = '#32CD32';  // Lime green leaf
            ctx.fillRect(badFood.x * gridSize + 13, badFood.y * gridSize + 1, 3, 2);
            
            // Normal green for body
            ctx.fillStyle = '#ADDDBB';  
            for (let i = 1; i < snake.length; i++) {
                ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize - 2, gridSize - 2);
            }
            
            // Draw snake - darker head
            const headX = snake[0].x * gridSize
            const headY = snake[0].y * gridSize
            const headSize = gridSize - 2
            ctx.fillStyle = snake.length > 0 ? '#32A956' : '#ADDDBB';  // Darker green for head
            ctx.fillRect(headX, headY, headSize, headSize);

            // Draw two red eyes on head
            ctx.fillStyle = '#ff0000';  // Bright red eyes
            const eyeSize = 4;
            const eyeOffset = 4;
            
            // Left eye
            ctx.fillRect(headX + eyeOffset, headY + eyeOffset, eyeSize, eyeSize);
            // Right eye  
            ctx.fillRect(headX + headSize - eyeOffset - eyeSize, headY + eyeOffset, eyeSize, eyeSize);
            
            // White highlight on eyes for shine effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fillRect(headX + eyeOffset + 1, headY + eyeOffset + 1, 2, 2);
            ctx.fillRect(headX + headSize - eyeOffset - eyeSize + 1, headY + eyeOffset + 1, 2, 2);
        }

        // Update game state
        function update() {
            if (!gameRunning) return;

            if (inputQueue.length > 0) {
                const queuedDirection = inputQueue.shift();
                dx = queuedDirection.dx;
                dy = queuedDirection.dy;
            }

            // Don't move if no direction set
            if (dx === 0 && dy === 0) return;

            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            
            // Check wall collision
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver();
                return;
            }

            // Check self collision
            for (let segment of snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    gameOver();
                    return;
                }
            }

            // Check bad food collision
            if (head.x === badFood.x && head.y === badFood.y) {
                gameOver();
                return;
            }
            
            snake.unshift(head);

            // Check food collision
            if (head.x === food.x && head.y === food.y) {

                // Play sound
                if (soundToggle.checked) {
                    const gameOverSound = document.getElementById('foodEatingSound');
                    gameOverSound.currentTime = 0;  // Reset to start
                    gameOverSound.play().catch(e => console.log('Sound play failed:', e));
                }
                
                score += 10;
                scoreElement.textContent = score;
                updateLevelDisplay(score); 

                // Update high score
                setHighScore(score);
                
                gameSpeed = getGameSpeed(score);
                
                randomFood();
                if (Math.random() < 0.2) {  // 20% chance
                    randomBadFood();
                }
            } else {
                snake.pop();
            }
        }

        // Adjust game speed
        function getGameSpeed(score) {
            // Beginner (0-100): Very forgiving
            if (score < 100) return 200 - (score * 0.5);  // 200→175ms
            
            // Novice (100-300): Noticeable speedup  
            else if (score < 300) return 175 - ((score-100) * 0.25); // 175→125ms
            
            // Intermediate (300-600): Tense
            else if (score < 600) return 125 - ((score-300) * 0.1);  // 125→95ms
            
            // Expert (600-900): Brutal
            else if (score < 900) return 95 - ((score-600) * 0.05);  // 95→80ms
            
            // God-tier (900+): Impossible for humans
            else return Math.max(50, 80 - ((score-900) * 0.02));     // 80→50ms
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            gameOverElement.style.visibility = 'visible';

            // ADD: Update leaderboard with FINAL score only
            updateLeaderboard(score);

            // Play sound
            if (soundToggle.checked) {
                const gameOverSound = document.getElementById('gameOverSound');
                gameOverSound.currentTime = 0;  // Reset to start
                gameOverSound.play().catch(e => console.log('Sound play failed:', e));
            }
        }

        // Restart game
        function restart() {
            snake = [{x: 10, y: 10}];
            dx = 0;
            dy = 0;
            score = 0;
            scoreElement.textContent = score;
            updateLevelDisplay(score); 
            updateHighScoreDisplay();
            gameOverElement.style.visibility = 'hidden';
            gameRunning = true;
            
            // Resets game speed to default
            gameSpeed = 150
            lastUpdateTime = 0
            
            randomFood();
            randomBadFood()

            // Reset the input queue
            inputQueue = [];
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            const LEFT = 37, UP = 38, RIGHT = 39, DOWN = 40, R = 82;
        
            // R key ONLY restarts when game over
            if (e.keyCode === R && !gameRunning && gameOverElement.style.visibility === 'visible') {
                restart();
                return; // Don't process direction change after restart
            }

            if (!gameRunning) return;
            
            // Decide what the "current" direction is for validation
            const lastDir = inputQueue.length > 0 ? inputQueue.at(-1) : { dx, dy };

            if (e.keyCode === LEFT  && lastDir.dx !== 1  && lastDir.dx !== -1)  { inputQueue.push({ dx: -1, dy: 0}); console.log("LEFT"); }
            if (e.keyCode === UP    && lastDir.dy !== 1  && lastDir.dy !== -1)  { inputQueue.push({dx: 0, dy: -1}); console.log("UP"); }
            if (e.keyCode === RIGHT && lastDir.dx !== -1 && lastDir.dx !== 1)   { inputQueue.push({dx: 1, dy: 0}); console.log("RIGHT"); }
            if (e.keyCode === DOWN  && lastDir.dy !== -1 && lastDir.dy !== 1)   { inputQueue.push({dx: 0, dy: 1}); console.log("DOWN"); }
        });

        // Handle touch screen input
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener('touchend', (e) => {
            e.preventDefault();

            // Double-tap to restart
            if (!gameRunning) {
                const now = new Date().getTime();
                const tapLength = now - lastTap;
                
                if (tapLength < doubleTapDelay && tapLength > 0) {
                    restart();
                    return;
                }
                lastTap = now;
                return;
            }

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 20;
            
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                if (deltaX > 0 && dx !== -1) { dx = 1; dy = 0; }  // Right
                else if (deltaX < 0 && dx !== 1) { dx = -1; dy = 0; }  // Left
            }
            else if (Math.abs(deltaY) > minSwipeDistance) {
                if (deltaY > 0 && dy !== -1) { dx = 0; dy = 1; }  // Down
                else if (deltaY < 0 && dy !== 1) { dx = 0; dy = -1; }  // Up
            }
        }, { passive: false });
        
        // Game loop
        function gameLoop(time) {
            // Only update game logic when enough time passed
            if (time - lastUpdateTime >= gameSpeed) {
                update();
                lastUpdateTime = time;  // Reset timer
            }
            
            drawGame(); // Always draw smoothly
            requestAnimationFrame(gameLoop);
        }

        // Initialize and start
        randomFood();
        randomBadFood()
        updateHighScoreDisplay();
        displayLeaderboard();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
